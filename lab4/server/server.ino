/*! 
  \brief The function is called when a sketch starts.  
  It used for initialize variables, pin modes, start using libraries, etc. 
  The function will only run once, after each powerup or reset of the Arduino board.
 */
void setup() {
  Serial.begin(9600);
  Serial.setTimeout(100);
}


char board[3][3] = {
  {'-', '-', '-'},
  {'-', '-', '-'},
  {'-', '-', '-'}
}; //!< It represents the state of the game board.

String mode; //!< It used for save the value of the game mode.
String action; //!< It used for save the value of the action which user did.
int coordX; //!< It used for save the value of the coordinate of the user's push along the X axis.
int coordY; //!< It used for save the value of the coordinate of the user's push along the Y axis.
char turn; //!< It used for save the sign X or O.
int pushCount = 0; //!< It used for save the quantity of user's pushes.
int winsPlayerX = 0; //!< It used for save the quantity of X's wins.
int winsPlayer0 = 0; //!< It used for save the quantity of O's wins.

char player = '1', AI = '0';  //!< It used for save the sign of the player and the AI.

/*! 
  \brief The function used for reset the game board. 
*/
void resetBoard() {
  for (int i = 0; i < 3; i++)
    for (int j = 0; j < 3; j++) 
      board[i][j] = '-';
}

/*!
  \brief The function used for parse the config which received from the client side of the game. 
  \param config The config is the string which contains the necessary data.
*/
void parse(String config) {
  config.replace("\r\n", "");
  config.replace("b'", "");
  config.replace("'", "");

  String key = "";
  String value = "";
  bool readKey = true;

  for (int i = 0; i < config.length(); i++) {
    char curr = config[i];

    if (curr != ';') {
      if (curr == '\n') {
        if (key == "mode") mode = value;
        if (key == "action") action = value;
        if (key == "coordX") coordX = value.toInt();
        if (key == "coordY") coordY = value.toInt();
        if (key == "turn") turn = value[0];

        key = "";
        value = "";
      }

      if (readKey) {
        if (curr != '=') {
          key += curr;
        } else {
          readKey = false;
        }
      } else {
        if (curr != '\n') 
          value += curr;
        else readKey = true;
      }
    }
  }
}about:blank#blocked

/*!
  \brief The function used for check the win. 
  \return Return true when there is a winner or false when there isn't a winner. 
*/
bool checkWin() {
  for (int i = 0; i < 3; i++) {
    if (board[0][i] == board[1][i] && board[0][i] == board[2][i] && board[0][i] != '-') {
      return true;
    }
  }

  for (int i = 0; i < 3; i++) {
    if (board[i][0] == board[i][1] && board[i][0] == board[i][2] && board[i][0] != '-') {
      return true;
    }
  }

  if (board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[0][0] != '-') {
    return true;
  }

  if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != '-') {
    return true;
  }

  return false;
}

/*! 
  \brief The struct used for save the 2d coordinates which was generated by AI. 
*/
struct Move 
{ 
    int row, col; 
};

/*! 
  \brief The function checks if there are moves on the board.
  \return This function returns true if there are moves remaining on the board of false if there are no moves left to play. 
*/
bool isMovesLeft() 
{ 
    for (int i = 0; i<3; i++) 
        for (int j = 0; j<3; j++) 
            if (board[i][j]=='-') 
                return true; 
    return false; 
} 
  
/*! 
  \brief The idea of the function is to give a high value for a board if the maximizer turn or a low value for the board if the minimizer turn. 
  \return Returns a integer value based on who is winning.
*/
int evaluate() 
{ 
    for (int row = 0; row<3; row++) 
    { 
        if (board[row][0]==board[row][1] && 
            board[row][1]==board[row][2]) 
        { 
            if (board[row][0]==AI) 
                return +10; 
            else if (board[row][0]==player) 
                return -10; 
        } 
    } 
  
    for (int col = 0; col<3; col++) 
    { 
        if (board[0][col]==board[1][col] && 
            board[1][col]==board[2][col]) 
        { 
            if (board[0][col]==AI) 
                return +10; 
  
            else if (board[0][col]==player) 
                return -10; 
        } 
    } 
  
    if (board[0][0]==board[1][1] && board[1][1]==board[2][2]) 
    { 
        if (board[0][0]==AI) 
            return +10; 
        else if (board[0][0]==player) 
            return -10; 
    } 
  
    if (board[0][2]==board[1][1] && board[1][1]==board[2][0]) 
    { 
        if (board[0][2]==AI) 
            return +10; 
        else if (board[0][2]==player) 
            return -10; 
    } 

    return 0; 
} 
  
/*! 
  \brief This is the minimax function.
  It considers all the possible ways the game can go and returns the value of the board.
  \param depth The depth of recursive.
  \param isMax The param used for switch beetween maximizer and minimizer.
  \return Returns a integer value based on the score of the board.
*/
int minimax(int depth, bool isMax) 
{ 
    int score = evaluate(); 

    if (score == 10) 
        return score; 

    if (score == -10) 
        return score; 

    if (isMovesLeft()==false) 
        return 0; 
  
    if (isMax) 
    { 
        int best = -1000; 
  
        for (int i = 0; i<3; i++) 
        { 
            for (int j = 0; j<3; j++) 
            { 
                if (board[i][j]=='-') 
                {  
                    board[i][j] = AI; 

                    int val = minimax(depth+1, !isMax);
                    if (val > best)
                      best = val;
                         
                    board[i][j] = '-'; 
                } 
            } 
        } 
        return best; 
    } 
   
    else
    { 
        int best = 1000; 
  
        for (int i = 0; i<3; i++) 
        { 
            for (int j = 0; j<3; j++) 
            { 
                if (board[i][j]=='-') 
                { 
                    board[i][j] = player; 
   
                    int val = minimax(depth+1, !isMax); 
                    if (val < best)
                      best = val; 
                           
                    board[i][j] = '-'; 
                } 
            } 
        } 
        return best; 
    } 
} 
  
/*! 
  \brief The function finds the best move.  
  This function evaluates all the available moves using minimax function.
  \return Returns the best move the maximizer can make. The returned value is a Move struct.
*/
struct Move findBestMove() 
{ 
    int bestVal = -1000; 
    Move bestMove; 
    bestMove.row = -1; 
    bestMove.col = -1; 
  
    for (int i = 0; i<3; i++) 
    { 
        for (int j = 0; j<3; j++) 
        { 
            if (board[i][j]=='-') 
            { 
                board[i][j] = AI; 
  
                int moveVal = minimax(0, false); 
  
                board[i][j] = '-'; 
  
                if (moveVal > bestVal) 
                { 
                    bestMove.row = i; 
                    bestMove.col = j; 
                    bestVal = moveVal; 
                } 
            } 
        } 
    } 
    return bestMove; 
} 

/*! 
  \brief Main program entry.  
  The function does loops consecutively, allowing the program to change and respond. It used for actively control the Arduino board.
  The function sends and receives configs from the client side of the game. 
  Controls the user's actions, game state. 
  Checks the winner or draw result of the game.
*/
void loop() {
  String config = "";
  bool isWinner = false;
  
  while(true) {
    if (Serial.available() > 0) {
      config += Serial.readString();
      if (config[config.length() - 1] == ';') break;
    }
  }

  parse(config);

  if (action == "PUSH") {
    if (mode == "PvsP" || mode == "PvsAI") {
      board[coordY][coordX] = turn;
      pushCount++;
      isWinner = checkWin();
    }
  } 
  else if (action == "RESET" || action == "CHANGE_MODE") {
    resetBoard();
    winsPlayerX = 0;
    winsPlayer0 = 0;
    pushCount = 0;
  } 
  else if (action == "CONTINUE") {
    resetBoard();
    pushCount = 0;
  }  
  else if (action == "GET_AI_PUSH") {
    if (mode == "AIvsAI") {
      if (pushCount % 2 == 0) {
        player = '0', AI = '1';
      } else {
        player = '1', AI = '0';
      }

      Move bestMove = findBestMove();
      pushCount++;
      board[bestMove.row][bestMove.col] = AI;
      turn = AI;
      isWinner = checkWin();
      Serial.println("coordX=" + String(bestMove.col) + String("\ncoordY=") + String(bestMove.row)  + String("\n"));
    } 
    else {
      Move bestMove = findBestMove();
      pushCount++;
      board[bestMove.row][bestMove.col] = '0';
      turn = '0';
      isWinner = checkWin();
      Serial.println("coordX=" + String(bestMove.col) + String("\ncoordY=") + String(bestMove.row)  + String("\n"));
    }
  }

  if (isWinner == false && pushCount > 8) {
    Serial.println("status=DRAW;");
    pushCount = 0;
  }

  if (isWinner == true) {
    if (turn == '0') {
      winsPlayer0++;
    } else {
      winsPlayerX++;
    }
    Serial.println("status=END\nwinner=" + String(turn) + String("\nwinsPlayerX=") + String(winsPlayerX) + String("\nwinsPlayer0=") + String(winsPlayer0) + String(";"));
    pushCount = 0;
  } 

  if (isWinner == false && pushCount < 9) {
    Serial.println("status=IN_PROCESS" + String(";"));
  }
}
